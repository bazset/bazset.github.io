<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ABC Fun Game - Precached</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Custom animations */
        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          25% { transform: translateX(-10px) rotate(-5deg); }
          75% { transform: translateX(10px) rotate(5deg); }
        }
        .animate-shake {
          animation: shake 0.4s ease-in-out;
        }
        @keyframes bounce-custom {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.2); }
        }
        .animate-bounce-custom {
          animation: bounce-custom 0.5s ease-in-out;
        }
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin-slow {
          animation: spin 3s linear infinite;
        }
        /* Fade in for screens */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
    </style>
</head>
<body class="min-h-screen bg-slate-100 touch-manipulation select-none flex flex-col items-center justify-center text-slate-800">

    <div id="app-container" class="w-full max-w-3xl p-4">
        <!-- Content will be injected here -->
    </div>

    <script>
        // --- CONSTANTS ---
        const ALPHABET_FULL = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
        const TOTAL_ROUNDS = 10;
        const COLORS = [
            'bg-red-400', 'bg-blue-400', 'bg-green-400', 
            'bg-yellow-400', 'bg-purple-400', 'bg-orange-400', 'bg-pink-400'
        ];

        // Core TTS Phrases 
        const instructionPrefix = "Find the "; 
        const praisePhrase = "Yes, you got it!";
        const incorrectPhrase = "No, that's the wrong letter.";
        
        // --- GAME STATE ---
        let gameState = 'loading'; // 'loading', 'start', 'playing', 'end'
        let round = 0;
        let score = 0;
        let targetLetter = '';
        let options = [];
        let isSpeaking = false;
        let nextTarget = '';
        
        // State for Loading Screen
        const TOTAL_ITEMS_TO_LOAD = ALPHABET_FULL.length + 3; // 26 letters + 3 core phrases
        let loadingProgress = 0; // 0 to 100
        let loadingStatusText = 'Connecting to audio service...';

        // Filtered alphabet containing only letters with successfully cached audio
        let ALPHABET_PLAYABLE = []; 
        
        // Audio Caches
        const audioCache = {}; // Stores { 'text': Blob }
        let currentAudio = null; // Currently playing HTML audio element
        
        // --- UTILITY FUNCTIONS ---
        
        const getRandomPlayable = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const shuffle = (arr) => [...arr].sort(() => Math.random() - 0.5);

        // Converts Base64 string to ArrayBuffer
        const base64ToArrayBuffer = (base64) => {
          const binaryString = atob(base64);
          const len = binaryString.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        };
        
        // Converts raw PCM audio data (ArrayBuffer) to a playable WAV Blob
        const pcmToWav = (pcmData, sampleRate) => {
            const numChannels = 1;
            const bitDepth = 16;
            const pcm16 = new Int16Array(pcmData); 
            const buffer = new ArrayBuffer(44 + pcm16.length * 2); 
            const view = new DataView(buffer);
            
            const writeString = (view, offset, str) => {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            };

            let offset = 0;

            // RIFF chunk descriptor
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + pcm16.length * 2, true); offset += 4; 
            writeString(view, offset, 'WAVE'); offset += 4;

            // fmt chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; 
            view.setUint16(offset, 1, true); offset += 2; // PCM format
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * (bitDepth / 8), true); offset += 4;
            view.setUint16(offset, numChannels * (bitDepth / 8), true); offset += 2;
            view.setUint16(offset, bitDepth, true); offset += 2;

            // data chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcm16.length * 2, true); offset += 4; 

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true); offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        };

        const playAudioBlob = (blob, onEnd = () => {}) => {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.removeAttribute('src');
                currentAudio = null;
            }
            
            const audioUrl = URL.createObjectURL(blob);
            currentAudio = new Audio(audioUrl);
            
            currentAudio.onended = () => {
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
                onEnd();
            };

            currentAudio.play().catch(e => console.error("Audio playback failed:", e));
        };
        
        // --- TTS API HANDLING (Robust Fetch with Retry) ---
        
        const fetchWithRetry = async (url, options, retries = 3) => {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // Throw non-temporary errors immediately
                        if (response.status !== 429 && i < retries - 1) { 
                             throw new Error(`Non-retryable HTTP error! Status: ${response.status}`);
                        }
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i < retries - 1) {
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 500; // Exponential backoff
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error; 
                    }
                }
            }
        };

        const fetchAudioAndCache = async (text) => {
            if (audioCache[text]) return audioCache[text];

            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        // Using a high-quality, human-like voice: Kore
                        voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } 
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };
            
            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const match = mimeType.match(/rate=(\d+)/);
                const sampleRate = match ? parseInt(match[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const wavBlob = pcmToWav(pcmData, sampleRate);
                
                // Store in memory cache
                audioCache[text] = wavBlob;
                return wavBlob;
            }
            throw new Error("API response incomplete: Missing audio data.");
        };
        
        /**
         * Updates the progress bar state and re-renders the loading screen.
         */
        const updateLoadingProgress = (text, currentCount, total, isSuccess) => {
            loadingProgress = Math.round((currentCount / total) * 100);
            const displayId = text.length > 2 ? text.substring(0, 15) + '...' : `Letter ${text}`;
            loadingStatusText = isSuccess 
                ? `Loaded: ${displayId}` 
                : `Skipping: ${displayId} (Failed to load)`;
            render(); 
        };

        /**
         * Preloads ALL core and letter audio clips and filters the alphabet.
         * Uses Promise.all to track all requests concurrently for speed.
         */
        const preloadAllAudio = async () => {
            const letterPhrases = ALPHABET_FULL.map(l => ({ 
                letter: l, 
                text: 'Letter ' + l + '.',
                isLetter: true
            }));
            
            const corePhrases = [
                { text: instructionPrefix, isLetter: false },
                { text: praisePhrase, isLetter: false },
                { text: incorrectPhrase, isLetter: false }
            ];
            
            const allPhrases = [...corePhrases, ...letterPhrases];
            const totalItems = allPhrases.length;
            let settledCount = 0;

            const promisesWithTracking = allPhrases.map((p) => {
                // Track success/failure and update progress
                return fetchAudioAndCache(p.text)
                    .then(blob => {
                        // Success tracking
                        const text = p.isLetter ? p.letter : p.text;
                        settledCount++;
                        updateLoadingProgress(text, settledCount, totalItems, true);
                        return { ...p, status: 'fulfilled', blob, text: p.text };
                    })
                    .catch(error => {
                        // Failure/Timeout tracking - we skip the item and proceed
                        const text = p.isLetter ? p.letter : p.text;
                        console.warn(`Failed to cache audio for: ${text}`, error.message);
                        settledCount++;
                        updateLoadingProgress(text, settledCount, totalItems, false);
                        return { ...p, status: 'rejected', reason: error, text: p.text };
                    });
            });

            // Wait for all requests (successful or failed) to complete concurrently
            const results = await Promise.all(promisesWithTracking); 
            
            let successfulLetters = [];
            
            results.forEach(result => {
                if (result.status === 'fulfilled' && result.isLetter) {
                    successfulLetters.push(result.letter);
                }
            });
            
            // Set final state and progress bar to 100
            loadingProgress = 100;
            loadingStatusText = 'Ready to start!';
            
            if (successfulLetters.length === 0) {
                 // Fallback if NO letters load (critical failure)
                 console.error("CRITICAL ERROR: No letter audio clips could be loaded. Game is unplayable.");
                 // Use a custom modal in future, but for now:
                 alert("Cannot start game: Failed to load letter audio. Please try again later.");
                 return;
            }
            
            // Set the playable alphabet based on successful caches
            ALPHABET_PLAYABLE = successfulLetters;
            gameState = 'start';
            console.log(`Successfully cached ${ALPHABET_PLAYABLE.length} letters: ${ALPHABET_PLAYABLE.join(', ')}`);
            render();
        }
        
        // Sequential audio player. Guarantees instant high-quality audio because everything is precached.
        const playSequentialAudio = (texts, onFinish = () => {}) => {
            if (!texts || texts.length === 0) {
                onFinish();
                return;
            }

            isSpeaking = true;
            render();

            const playNext = () => {
                const text = texts.shift();
                if (!text) {
                    isSpeaking = false;
                    onFinish();
                    render();
                    return;
                }

                const cachedBlob = audioCache[text];
                if (cachedBlob) {
                    playAudioBlob(cachedBlob, playNext);
                } else {
                    // Should not happen if preloading was successful, but handle defensively
                    console.error(`Missing required cached audio for: ${text}`);
                    playNext();
                }
            };

            playNext();
        };

        // Simple speech function for single-phrase.
        const speakSingle = async (text, onFinish = () => {}) => {
            if (isSpeaking) {
                onFinish();
                return;
            }
            
            isSpeaking = true;
            render();
            
            const cachedBlob = audioCache[text];
            if (cachedBlob) {
                playAudioBlob(cachedBlob, () => {
                    isSpeaking = false;
                    onFinish();
                    render();
                });
            } else {
                console.error(`Missing required cached audio for: ${text}`);
                isSpeaking = false;
                onFinish();
                render();
            }
        };


        // --- GAME LOGIC ---

        const getNextTarget = () => {
            // Use the filtered playable alphabet
            if (ALPHABET_PLAYABLE.length === 0) return ''; 
            
            let next;
            do {
              next = getRandomPlayable(ALPHABET_PLAYABLE);
            } while (options.includes(next)); // Simple check to avoid immediate repeats in options
            return next;
        };

        const setupRound = () => {
            const target = nextTarget || getRandomPlayable(ALPHABET_PLAYABLE);
            targetLetter = target;
            
            // Get the next target for the *next* round to pre-cache its card
            nextTarget = getNextTarget(); 
            
            let distractors = [];
            // Select distractors only from the playable alphabet
            while (distractors.length < 2) {
              let d = getRandomPlayable(ALPHABET_PLAYABLE);
              if (d !== target && !distractors.includes(d)) {
                distractors.push(d);
              }
            }

            options = shuffle([target, ...distractors]);
            
            // Clear previous animation states
            const cards = document.querySelectorAll('.game-card');
            cards.forEach(card => card.classList.remove('animate-shake', 'animate-bounce-custom', 'ring-8', 'ring-red-400', 'ring-green-400'));
            
            const feedbackElement = document.getElementById('feedback-text');
            if(feedbackElement) {
                feedbackElement.textContent = `${instructionPrefix.trim()} ${targetLetter}`;
            }
            
            // Play instruction using the precached audio
            playSequentialAudio([instructionPrefix, 'Letter ' + targetLetter + '.']); 
        };

        window.handleGuess = (letter, cardElement) => {
            if (cardElement.classList.contains('animate-bounce-custom') || isSpeaking) return;

            if (letter === targetLetter) {
                score++;
                document.getElementById('score').textContent = score;
                document.getElementById('feedback-text').textContent = praisePhrase;
                
                cardElement.classList.add('animate-bounce-custom', 'ring-8', 'ring-green-400');
                
                speakSingle(praisePhrase);

                setTimeout(() => {
                    if (round >= TOTAL_ROUNDS) {
                        gameState = 'end';
                        const gameOverText = `Game over! You got ${score} stars!`;
                        speakSingle(gameOverText); 

                    } else {
                        round++;
                        setupRound(); 
                    }
                    render();
                }, 2000);

            } else {
                document.getElementById('feedback-text').textContent = `${incorrectPhrase} Find the letter ${targetLetter}.`;
                
                cardElement.classList.add('animate-shake', 'ring-8', 'ring-red-400');
                
                // Play incorrect phrase and repeat instruction, all using precached audio
                playSequentialAudio([incorrectPhrase, instructionPrefix, 'Letter ' + targetLetter + '.'], () => {
                    cardElement.classList.remove('animate-shake', 'ring-8', 'ring-red-400');
                    render();
                });
                render();
            }
        };

        window.startGame = () => {
            if (gameState === 'loading' || ALPHABET_PLAYABLE.length === 0) return; 

            gameState = 'playing';
            score = 0;
            round = 1;
            
            nextTarget = getNextTarget(); 
            
            render(); 
            setupRound(); 
        };

        window.repeatInstruction = () => {
            if (gameState === 'playing' && targetLetter) {
                // Repeat instruction using precached audio
                playSequentialAudio([instructionPrefix, 'Letter ' + targetLetter + '.']); 
            }
        }
        
        // --- RENDERING FUNCTIONS (DOM Manipulation) ---

        const renderLoadingScreen = () => {
            return `
                <div class="text-center p-8 max-w-lg w-full mx-auto">
                    <h1 class="text-6xl font-black text-blue-500 mb-8 tracking-wider drop-shadow-md">
                        ABC Fun
                    </h1>
                    <div class="bg-white p-8 rounded-3xl shadow-xl border-4 border-blue-200">
                        <!-- Progress Bar Container -->
                        <div class="mb-6">
                            <div class="flex justify-between mb-1 text-sm font-medium text-slate-600">
                                <span>Audio Pre-caching (${loadingProgress}%)</span>
                            </div>
                            <div class="w-full bg-slate-200 rounded-full h-4">
                                <div 
                                    class="bg-blue-500 h-4 rounded-full transition-all duration-500 ease-out" 
                                    style="width: ${loadingProgress}%"
                                ></div>
                            </div>
                        </div>
                        
                        <svg class="animate-spin h-10 w-10 text-blue-500 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        
                        <p id="loading-status-text" class="text-xl text-slate-500 font-medium h-6">
                            ${loadingStatusText}
                        </p>
                        <p class="text-sm text-slate-400 mt-2">
                            Caching ${TOTAL_ITEMS_TO_LOAD} audio clips for instant playback.
                        </p>
                    </div>
                </div>
            `;
        }

        const renderStartScreen = () => {
            const buttonClass = 'bg-green-500 hover:bg-green-600 border-green-600';
            
            let statusMessage = `Ready to play! You have ${ALPHABET_PLAYABLE.length} letters with crystal-clear audio.`;

            return `
                <div class="text-center p-8 animate-fade-in max-w-lg w-full mx-auto">
                    <h1 class="text-6xl font-black text-blue-500 mb-8 tracking-wider drop-shadow-md">
                        ABC Fun
                    </h1>
                    <div class="bg-white p-8 rounded-3xl shadow-xl border-4 border-blue-200">
                        <p class="text-xl text-slate-500 mb-8 font-medium">
                            ${statusMessage}
                        </p>
                        <button 
                            onclick="startGame()"
                            class="w-full text-white text-4xl font-bold py-8 rounded-2xl shadow-lg border-b-8 transition-all flex items-center justify-center gap-3 active:scale-95 ${buttonClass}"
                        >
                            Start Game
                        </button>
                    </div>
                </div>
            `;
        };

        const renderGameScreen = () => {
            const cardsHtml = options.map((letter) => {
                const colorClass = COLORS[letter.charCodeAt(0) % COLORS.length];
                return `
                    <button
                        onclick="handleGuess('${letter}', this)"
                        class="game-card w-full h-full max-h-64 aspect-square
                            flex items-center justify-center
                            rounded-3xl shadow-xl border-b-8 border-black/10
                            text-8xl md:text-9xl font-black text-white
                            transition-transform duration-200
                            active:scale-95 active:border-b-0
                            ${colorClass}
                            ${isSpeaking ? 'disabled:opacity-70 cursor-not-allowed' : ''}
                        "
                        style="text-shadow: 2px 2px 0px rgba(0,0,0,0.2);"
                        ${isSpeaking ? 'disabled' : ''}
                    >
                        ${letter}
                    </button>
                `;
            }).join('');

            return `
                <div class="w-full h-screen flex flex-col max-w-3xl mx-auto p-4">
                    <!-- Header -->
                    <div class="flex justify-between items-center mb-4 bg-white p-4 rounded-2xl shadow-sm border-2 border-slate-100">
                        <div class="flex items-center gap-2">
                            <span class="text-2xl font-bold text-slate-400">Round ${round}/${TOTAL_ROUNDS}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <svg class="w-8 h-8 text-yellow-400 fill-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26l6.91 1.01l-5 4.88l1.18 6.88l-6.18-3.25l-6.18 3.25l1.18-6.88l-5-4.88l6.91-1.01z"/></svg>
                            <span id="score" class="text-3xl font-black text-slate-700">${score}</span>
                        </div>
                    </div>

                    <!-- Prompt Area -->
                    <div class="text-center mb-6 h-16 flex items-center justify-center">
                        <h2 id="feedback-text" class="text-3xl md:text-4xl font-bold text-slate-600 transition-all">
                            Find the letter ${targetLetter}
                        </h2>
                    </div>

                    <!-- Cards Grid -->
                    <div class="flex-1 grid grid-cols-1 md:grid-cols-3 gap-6 mb-8 place-items-center">
                        ${cardsHtml}
                    </div>

                    <!-- Replay Instructions Button -->
                    <div class="flex justify-center pb-8">
                        <button 
                            onclick="repeatInstruction()"
                            ${isSpeaking ? 'disabled' : ''}
                            class="bg-slate-200 p-4 rounded-full text-slate-500 hover:bg-slate-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            aria-label="Repeat Instruction"
                        >
                            ${isSpeaking ? 
                                `<svg class="w-8 h-8 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.207 15.354L4 15.192M4 12a8 8 0 0116 0" />
                                </svg>` : 
                                `<svg class="w-8 h-8" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14.5 2C12.16 2 10 4.16 10 6.5s2.16 4.5 4.5 4.5S19 8.84 19 6.5S16.84 2 14.5 2zM12 16H8v-4h4v4zM22 18H2v2h20v-2zM16 16v4h-4v-4h4zM4 16v4H2v-4H4zM22 16H18v4h4v-4z"/></svg>`
                            }
                        </button>
                    </div>
                </div>
            `;
        };

        const renderEndScreen = () => {
            return `
                <div class="text-center p-6 animate-fade-in w-full max-w-lg mx-auto">
                    <div class="bg-white p-8 rounded-3xl shadow-2xl border-4 border-yellow-200 relative overflow-hidden">
                        
                        <div class="absolute top-0 left-0 w-full h-2 bg-yellow-400"></div>

                        <h2 class="text-5xl font-black text-slate-700 mb-2">All Done!</h2>
                        <div class="flex justify-center items-center gap-2 mb-8">
                            <svg class="w-12 h-12 text-yellow-400 fill-yellow-400 animate-spin-slow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26l6.91 1.01l-5 4.88l1.18 6.88l-6.18-3.25l-6.18 3.25l1.18-6.88l-5-4.88l6.91-1.01z"/></svg>
                            <span class="text-8xl font-black text-yellow-500">${score}</span>
                            <svg class="w-12 h-12 text-yellow-400 fill-yellow-400 animate-spin-slow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26l6.91 1.01l-5 4.88l1.18 6.88l-6.18-3.25l-6.18 3.25l1.18-6.88l-5-4.88l6.91-1.01z"/></svg>
                        </div>
                        
                        <p class="text-xl text-slate-500 mb-8">
                            ${score === 10 ? "Perfect Score! You're a genius!" : "Great practice!"}
                        </p>

                        <button 
                            onclick="startGame()"
                            class="w-full bg-blue-500 hover:bg-blue-600 text-white text-3xl font-bold py-6 rounded-2xl shadow-lg border-b-8 border-blue-600 flex items-center justify-center gap-3 active:scale-95 transition-all"
                        >
                            <svg class="w-8 h-8" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 6.5C10.73 6.5 9.69 7.54 9.69 8.81V11.5H7v2h2.69v5.69c0 1.27 1.04 2.31 2.31 2.31s2.31-1.04 2.31-2.31V13.5H17v-2h-2.69V8.81C14.31 7.54 13.27 6.5 12 6.5zM12 8.5C12.79 8.5 13.43 9.14 13.43 9.93V11.5H10.57V9.93C10.57 9.14 11.21 8.5 12 8.5z"/></svg>
                            Play Again
                        </button>
                    </div>
                </div>
            `;
        };

        const render = () => {
            const appContainer = document.getElementById('app-container');
            let html = '';

            if (gameState === 'loading') {
                html = renderLoadingScreen();
            } else if (gameState === 'start') {
                html = renderStartScreen();
            } else if (gameState === 'playing') {
                html = renderGameScreen();
            } else if (gameState === 'end') {
                html = renderEndScreen();
            }
            
            appContainer.innerHTML = html;
        };
        
        const initializeApp = async () => {
            render(); 
            await preloadAllAudio();
            render(); // Transition from loading to start
        };

        window.onload = function() {
            initializeApp();
        };

    </script>
</body>
</html>