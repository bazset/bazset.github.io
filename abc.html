<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ABC Fun Game</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wghtã‚‚è¦‹äº‹400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Custom animations */
        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          25% { transform: translateX(-10px) rotate(-5deg); }
          75% { transform: translateX(10px) rotate(5deg); }
        }
        .animate-shake {
          animation: shake 0.4s ease-in-out;
        }
        @keyframes bounce-custom {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.2); }
        }
        .animate-bounce-custom {
          animation: bounce-custom 0.5s ease-in-out;
        }
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin-slow {
          animation: spin 3s linear infinite;
        }
    </style>
</head>
<body class="min-h-screen bg-slate-100 touch-manipulation select-none flex flex-col items-center justify-center text-slate-800">

    <div id="app-container" class="w-full max-w-3xl p-4">
        <!-- Content will be injected here -->
    </div>

    <!-- Background Loading Banner -->
    <div id="loading-banner" class="fixed top-0 left-0 w-full bg-blue-500 text-white text-center py-2 text-sm font-medium transition-transform duration-500 transform translate-y-0 shadow-lg">
        <div id="loading-message" class="flex items-center justify-center gap-2">
            <svg class="w-4 h-4 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.207 15.354L4 15.192M4 12a8 8 0 0116 0" />
            </svg>
            <span id="loading-text">Preparing audio assets...</span>
        </div>
    </div>


    <script type="module">
        // --- CONSTANTS ---
        const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
        const TOTAL_ROUNDS = 10;
        const FETCH_TIMEOUT_MS = 8000; // 8 second hard timeout for any single fetch
        const COLORS = [
            'bg-red-400', 'bg-blue-400', 'bg-green-400', 
            'bg-yellow-400', 'bg-purple-400', 'bg-orange-400', 'bg-pink-400'
        ];

        // --- GAME STATE ---
        let gameState = 'start'; // 'start', 'playing', 'end'
        let round = 0;
        let score = 0;
        let targetLetter = '';
        let options = [];
        let isSpeaking = false;
        let nextTarget = '';
        
        let failedAudioCount = 0;
        let totalAudios = 0; // Total expected audios
        let audiosLoaded = 0; // Audios successfully loaded/cached
        let totalProcessed = 0; // Total number of fetch attempts completed (success or failure)

        // Audio Caches
        const audioCache = {}; // Runtime cache (Blob/ArrayBuffer)
        const LOCAL_STORAGE_PREFIX = 'abc_audio_';
        let currentAudio = null; // Global audio element for stopping playback

        // Optimized Phrases for Caching
        // UPDATED: Now fetches "Find the " separately from "Letter A."
        const instructionPrefix = "Find the "; 
        const praisePhrase = "Yes, you got it!";
        const incorrectPhrase = "No, that's the wrong letter.";
        
        // --- NATIVE SPEECH FALLBACK SETUP ---
        let nativeSpeechSupported = 'speechSynthesis' in window;
        let fallbackVoice = null;
        
        // Get an English voice if supported (usually takes a moment)
        if (nativeSpeechSupported) {
            window.speechSynthesis.onvoiceschanged = () => {
                fallbackVoice = window.speechSynthesis.getVoices().find(v => v.lang === 'en-US' || v.lang.startsWith('en')) || null;
            };
            // Try to get voices immediately if they are already loaded
            fallbackVoice = window.speechSynthesis.getVoices().find(v => v.lang === 'en-US' || v.lang.startsWith('en')) || null;
        }

        // --- DOM ELEMENTS ---
        const loadingBanner = document.getElementById('loading-banner');
        const loadingTextSpan = document.getElementById('loading-text');

        // --- UTILITY FUNCTIONS ---
        
        const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];
        const shuffle = (arr) => [...arr].sort(() => Math.random() - 0.5);

        // Helper to wrap a promise with a timeout
        const withTimeout = (promise, ms, message = "Timeout reached") => {
            return new Promise((resolve, reject) => {
                const timer = setTimeout(() => reject(new Error(message)), ms);
                promise.then(resolve, reject).finally(() => clearTimeout(timer));
            });
        };
        
        // Converts Base64 string from localStorage to ArrayBuffer
        const base64ToArrayBuffer = (base64) => {
          const binaryString = atob(base64);
          const len = binaryString.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        };
        
        // Converts ArrayBuffer (PCM data) to Base64 string for localStorage
        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            // Ensure we treat the buffer correctly as bytes for conversion
            const bytes = new Uint8Array(buffer); 
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        };

        // Converts raw PCM audio data (ArrayBuffer) to a playable WAV Blob
        const pcmToWav = (pcmData, sampleRate) => {
            const numChannels = 1;
            const bitDepth = 16;
            const pcm16 = new Int16Array(pcmData);
            const buffer = new ArrayBuffer(44 + pcm16.length * 2);
            const view = new DataView(buffer);
            
            const writeString = (view, offset, str) => {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            };

            let offset = 0;

            // RIFF chunk descriptor
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + pcm16.length * 2, true); offset += 4; 
            writeString(view, offset, 'WAVE'); offset += 4;

            // fmt chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; 
            view.setUint16(offset, 1, true); offset += 2; // PCM format
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * (bitDepth / 8), true); offset += 4;
            view.setUint16(offset, numChannels * (bitDepth / 8), true); offset += 2;
            view.setUint16(offset, bitDepth, true); offset += 2;

            // data chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcm16.length * 2, true); offset += 4; 

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true); offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        };

        const playAudioBlob = (blob, onEnd = () => {}) => {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.removeAttribute('src');
                currentAudio = null;
            }
            
            const audioUrl = URL.createObjectURL(blob);
            currentAudio = new Audio(audioUrl);
            
            currentAudio.onended = () => {
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
                onEnd();
            };

            currentAudio.play().catch(e => console.error("Audio playback failed:", e));
        };
        
        // Native TTS Fallback Function
        const speakFallback = (text, onEnd = () => {}) => {
            if (!nativeSpeechSupported) {
                onEnd();
                return;
            }
            
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            if (fallbackVoice) {
                utterance.voice = fallbackVoice;
            }
            utterance.rate = 0.9; // Slightly slower for clarity
            
            utterance.onend = () => {
                onEnd();
            };

            try {
                window.speechSynthesis.speak(utterance);
            } catch (e) {
                console.error("Native speech failed:", e);
                onEnd();
            }
        };


        // Sequential audio player. Checks cache, falls back to native speech if missing.
        const playSequentialAudio = (texts, onFinish = () => {}) => {
            if (!texts || texts.length === 0) {
                onFinish();
                return;
            }
            
            if (isSpeaking) {
                onFinish();
                return;
            }

            isSpeaking = true;

            const playNext = () => {
                const text = texts.shift();
                if (!text) {
                    isSpeaking = false;
                    onFinish();
                    render();
                    return;
                }

                const blob = audioCache[text];
                if (blob) {
                    playAudioBlob(blob, playNext);
                } else {
                    console.warn(`Audio asset for: "${text}" not loaded. Falling back to native speech.`);
                    // --- FALLBACK: Use Native TTS ---
                    speakFallback(text, playNext);
                }
            };

            playNext();
        };

        // Simple speech function for single-phrase, cached items, with fallback
        const speakSingle = (text, priority = false, onFinish = () => {}) => {
            if (currentAudio && !priority) {
                onFinish();
                return;
            }
            if (isSpeaking) {
                onFinish();
                return;
            }
            
            const cachedBlob = audioCache[text];
            
            if (cachedBlob) {
                isSpeaking = true;
                playAudioBlob(cachedBlob, () => {
                    isSpeaking = false;
                    onFinish();
                    render();
                });
            } else {
                console.warn(`Audio asset for: "${text}" not loaded. Falling back to native speech.`);
                // --- FALLBACK: Use Native TTS ---
                isSpeaking = true;
                speakFallback(text, () => {
                    isSpeaking = false;
                    onFinish();
                    render();
                });
            }
            render();
        };


        // --- TTS API HANDLING with Local Storage ---

        const fetchAndCacheAudio = async (text) => {
            const localStorageKey = LOCAL_STORAGE_PREFIX + text;

            // 1. Check Local Storage first
            try {
                const cachedBase64 = localStorage.getItem(localStorageKey);
                if (cachedBase64) {
                    const pcmData = base64ToArrayBuffer(cachedBase64);
                    // Sample rate is fixed to 24000 for this model, hardcode it for WAV conversion
                    const wavBlob = pcmToWav(pcmData, 24000); 
                    audioCache[text] = wavBlob;
                    audiosLoaded++;
                    return wavBlob;
                }
            } catch (e) {
                console.warn("Could not read from local storage:", e);
                // Continue to fetch if reading cache failed
            }

            // 2. If not found in cache, proceed with API fetch
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            const fetchAttempt = async () => {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API returned status ${response.status}`);
                }

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const match = mimeType.match(/rate=(\d+)/);
                    const sampleRate = match ? parseInt(match[1], 10) : 24000;
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const wavBlob = pcmToWav(pcmData, sampleRate);
                    
                    // 3. Save to Local Storage on successful fetch
                    try {
                        const base64Data = arrayBufferToBase64(pcmData);
                        localStorage.setItem(localStorageKey, base64Data);
                    } catch (e) {
                        console.warn("Could not save to local storage:", e);
                    }

                    audioCache[text] = wavBlob;
                    audiosLoaded++;
                    return wavBlob;
                }
                throw new Error("Missing audio data in response.");
            };

            const maxRetries = 3;
            let delay = 500; 

            for (let i = 0; i < maxRetries; i++) {
                try {
                    // Apply hard timeout to the fetch attempt
                    return await withTimeout(fetchAttempt(), FETCH_TIMEOUT_MS, `Fetch for "${text}" timed out.`);
                } catch (error) {
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                    } else {
                        console.error(`Failed to generate audio for "${text}" after all retries. Skipping.`, error);
                        failedAudioCount++;
                        return null;
                    }
                }
            }
            return null;
        };
        
        


        // --- GAME LOGIC ---

        const getNextTarget = () => {
            let next;
            do {
              next = getRandom(ALPHABET);
            } while (options.includes(next));
            return next;
        };

        // Refactored from startRound to ensure UI switches before audio playback
        const setupRound = () => {
            const target = nextTarget || getRandom(ALPHABET);
            targetLetter = target;
            nextTarget = getNextTarget();
            
            let distractors = [];
            while (distractors.length < 2) {
              let d = getRandom(ALPHABET);
              if (d !== target && !distractors.includes(d)) {
                distractors.push(d);
              }
            }

            options = shuffle([target, ...distractors]);
            
            const cards = document.querySelectorAll('.game-card');
            cards.forEach(card => card.classList.remove('animate-shake', 'animate-bounce-custom', 'ring-8', 'ring-red-400', 'ring-green-400'));
            
            // NOTE: The feedback text MUST be updated on the DOM directly before audio starts
            const feedbackElement = document.getElementById('feedback-text');
            if(feedbackElement) {
                // Display text now includes the letter name structure for clarity
                feedbackElement.textContent = `${instructionPrefix.trim()} ${targetLetter}`;
            }
            
            // Play split instruction, using "Letter X." to ensure correct pronunciation
            playSequentialAudio([instructionPrefix, 'Letter ' + targetLetter + '.']); 
        };

        window.handleGuess = (letter, cardElement) => {
            // Prevent interaction while an instruction is being spoken
            if (cardElement.classList.contains('animate-bounce-custom') || isSpeaking) return;

            if (letter === targetLetter) {
                // CORRECT
                score++;
                document.getElementById('score').textContent = score;
                document.getElementById('feedback-text').textContent = 'Yes, you got it!';
                
                cardElement.classList.add('animate-bounce-custom', 'ring-8', 'ring-green-400');
                
                // Play single praise phrase (checks cache, falls back to native speech)
                speakSingle(praisePhrase, true);

                setTimeout(() => {
                    if (round >= TOTAL_ROUNDS) {
                        gameState = 'end';
                        // Game Over text is dynamic, ensure it uses speakSingle which has fallback
                        const gameOverText = `Game over! You got ${score} stars!`;
                        speakSingle(gameOverText, true); 

                    } else {
                        round++;
                        setupRound(); // Call the new round setup
                    }
                    render();
                }, 2000);

            } else {
                // INCORRECT
                document.getElementById('feedback-text').textContent = `No, that's the wrong letter. Find the letter ${targetLetter}.`;
                
                cardElement.classList.add('animate-shake', 'ring-8', 'ring-red-400');
                
                // Play complex incorrect instruction: No + Find + Letter X. (with fallback)
                playSequentialAudio([incorrectPhrase, instructionPrefix, 'Letter ' + targetLetter + '.'], () => {
                    // Remove shake after audio finishes
                    cardElement.classList.remove('animate-shake', 'ring-8', 'ring-red-400');
                    render();
                });
                render();
            }
        };

        window.startGame = () => {
            console.log("Starting game...");
            // 1. Reset state
            gameState = 'playing';
            score = 0;
            round = 1;
            
            nextTarget = getRandom(ALPHABET); 
            
            // 2. CRITICAL: Render the game screen IMMEDIATELY
            render(); 
            
            // 3. Setup the round and start audio ASYNCHRONOUSLY
            setupRound(); 
        };

        window.repeatInstruction = () => {
             // Play split instruction, using "Letter X." to ensure correct pronunciation
            playSequentialAudio([instructionPrefix, 'Letter ' + targetLetter + '.']); 
        }
        
        // --- RENDERING FUNCTIONS (DOM Manipulation) ---

        const renderStartScreen = () => {
            // Determine if we show a disabled button while loading
            const isFullyLoaded = totalProcessed >= totalAudios;
            // The button is no longer disabled, but the color indicates readiness.
            const buttonClass = isFullyLoaded
                ? 'bg-green-500 hover:bg-green-600 border-green-600'
                : 'bg-gray-400 hover:bg-gray-500 border-gray-500';

            return `
                <div class="text-center p-8 animate-fade-in max-w-lg w-full mx-auto">
                    <h1 class="text-6xl font-black text-blue-500 mb-8 tracking-wider drop-shadow-md">
                        ABC Fun
                    </h1>
                    <div class="bg-white p-8 rounded-3xl shadow-xl border-4 border-blue-200">
                        <p class="text-xl text-slate-500 mb-8 font-medium">
                            Ready to learn your letters? Let's play!
                        </p>
                        <button 
                            onclick="startGame()"
                            class="w-full text-white text-4xl font-bold py-8 rounded-2xl shadow-lg border-b-8 transition-all flex items-center justify-center gap-3 active:scale-95 ${buttonClass}"
                        >
                            Play! ðŸš€
                        </button>
                    </div>
                </div>
            `;
        };

        const renderGameScreen = () => {
            const cardsHtml = options.map((letter) => {
                const colorClass = COLORS[letter.charCodeAt(0) % COLORS.length];
                return `
                    <button
                        onclick="handleGuess('${letter}', this)"
                        class="game-card w-full h-full max-h-64 aspect-square
                            flex items-center justify-center
                            rounded-3xl shadow-xl border-b-8 border-black/10
                            text-8xl md:text-9xl font-black text-white
                            transition-transform duration-200
                            active:scale-95 active:border-b-0
                            ${colorClass}
                            ${isSpeaking ? 'disabled:opacity-70 cursor-not-allowed' : ''}
                        "
                        style="text-shadow: 2px 2px 0px rgba(0,0,0,0.2);"
                        ${isSpeaking ? 'disabled' : ''}
                    >
                        ${letter}
                    </button>
                `;
            }).join('');

            return `
                <div class="w-full h-screen flex flex-col max-w-3xl mx-auto p-4">
                    <!-- Header -->
                    <div class="flex justify-between items-center mb-4 bg-white p-4 rounded-2xl shadow-sm border-2 border-slate-100">
                        <div class="flex items-center gap-2">
                            <span class="text-2xl font-bold text-slate-400">Round ${round}/${TOTAL_ROUNDS}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <svg class="w-8 h-8 text-yellow-400 fill-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26l6.91 1.01l-5 4.88l1.18 6.88l-6.18-3.25l-6.18 3.25l1.18-6.88l-5-4.88l6.91-1.01z"/></svg>
                            <span id="score" class="text-3xl font-black text-slate-700">${score}</span>
                        </div>
                    </div>

                    <!-- Prompt Area -->
                    <div class="text-center mb-6 h-16 flex items-center justify-center">
                        <h2 id="feedback-text" class="text-3xl md:text-4xl font-bold text-slate-600 transition-all">
                            Find the letter ${targetLetter}
                        </h2>
                    </div>

                    <!-- Cards Grid -->
                    <div class="flex-1 grid grid-cols-1 md:grid-cols-3 gap-6 mb-8 place-items-center">
                        ${cardsHtml}
                    </div>

                    <!-- Replay Instructions Button -->
                    <div class="flex justify-center pb-8">
                        <button 
                            onclick="repeatInstruction()"
                            ${isSpeaking ? 'disabled' : ''}
                            class="bg-slate-200 p-4 rounded-full text-slate-500 hover:bg-slate-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            aria-label="Repeat Instruction"
                        >
                            ${isSpeaking ? 
                                `<svg class="w-8 h-8 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.207 15.354L4 15.192M4 12a8 8 0 0116 0" />
                                </svg>` : 
                                `<svg class="w-8 h-8" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14.5 2C12.16 2 10 4.16 10 6.5s2.16 4.5 4.5 4.5S19 8.84 19 6.5S16.84 2 14.5 2zM12 16H8v-4h4v4zM22 18H2v2h20v-2zM16 16v4h-4v-4h4zM4 16v4H2v-4H4zM22 16H18v4h4v-4z"/></svg>`
                            }
                        </button>
                    </div>
                </div>
            `;
        };

        const renderEndScreen = () => {
            return `
                <div class="text-center p-6 animate-fade-in w-full max-w-lg mx-auto">
                    <div class="bg-white p-8 rounded-3xl shadow-2xl border-4 border-yellow-200 relative overflow-hidden">
                        
                        <div class="absolute top-0 left-0 w-full h-2 bg-yellow-400"></div>

                        <h2 class="text-5xl font-black text-slate-700 mb-2">All Done!</h2>
                        <div class="flex justify-center items-center gap-2 mb-8">
                            <svg class="w-12 h-12 text-yellow-400 fill-yellow-400 animate-spin-slow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26l6.91 1.01l-5 4.88l1.18 6.88l-6.18-3.25l-6.18 3.25l1.18-6.88l-5-4.88l6.91-1.01z"/></svg>
                            <span class="text-8xl font-black text-yellow-500">${score}</span>
                            <svg class="w-12 h-12 text-yellow-400 fill-yellow-400 animate-spin-slow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26l6.91 1.01l-5 4.88l1.18 6.88l-6.18-3.25l-6.18 3.25l1.18-6.88l-5-4.88l6.91-1.01z"/></svg>
                        </div>
                        
                        <p class="text-xl text-slate-500 mb-8">
                            ${score === 10 ? "Perfect Score! You're a genius!" : "Great practice!"}
                        </p>

                        <button 
                            onclick="startGame()"
                            class="w-full bg-blue-500 hover:bg-blue-600 text-white text-3xl font-bold py-6 rounded-2xl shadow-lg border-b-8 border-blue-600 flex items-center justify-center gap-3 active:scale-95 transition-all"
                        >
                            <svg class="w-8 h-8" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 6.5C10.73 6.5 9.69 7.54 9.69 8.81V11.5H7v2h2.69v5.69c0 1.27 1.04 2.31 2.31 2.31s2.31-1.04 2.31-2.31V13.5H17v-2h-2.69V8.81C14.31 7.54 13.27 6.5 12 6.5zM12 8.5C12.79 8.5 13.43 9.14 13.43 9.93V11.5H10.57V9.93C10.57 9.14 11.21 8.5 12 8.5z"/></svg>
                            Play Again
                        </button>
                    </div>
                </div>
            `;
        };

        const render = () => {
            const appContainer = document.getElementById('app-container');
            let html = '';

            if (gameState === 'start') {
                html = renderStartScreen();
            } else if (gameState === 'playing') {
                html = renderGameScreen();
            } else if (gameState === 'end') {
                html = renderEndScreen();
            }
            
            appContainer.innerHTML = html;
        };
        
        // Updates the background loading banner text and state
        const updateLoadingBanner = () => {
            totalProcessed++; // Increment the counter regardless of success/failure
            
            if (totalProcessed >= totalAudios) {
                loadingBanner.classList.add('translate-y-[-100%]');
                loadingBanner.classList.remove('bg-blue-500');
                
                let completionMessage = `All ${totalAudios} audio assets loaded.`;
                if (failedAudioCount > 0) {
                    loadingBanner.classList.add('bg-yellow-500');
                    completionMessage = `${audiosLoaded} assets loaded, ${failedAudioCount} skipped. Game ready! (Using fallback speech where needed)`;
                } else {
                    loadingBanner.classList.add('bg-green-500');
                }
                
                document.getElementById('loading-message').innerHTML = `<span id="loading-text">${completionMessage}</span>`;
            } else {
                 let progress = Math.floor((totalProcessed / totalAudios) * 100);
                 let failedMsg = failedAudioCount > 0 ? ` (${failedAudioCount} failed)` : '';
                 loadingTextSpan.textContent = `Preparing audio (${progress}% complete) ${failedMsg}`;
            }
            // CRITICAL: Re-render the start screen to enable the Play button if loading finished.
            if (gameState === 'start') {
                render();
            }
        };


        // --- INITIALIZATION (Non-Blocking) ---

        const prefetchAllAudio = async () => {
            const textsToCache = new Set();

            // 1. Fixed phrases 
            textsToCache.add(instructionPrefix);
            textsToCache.add(praisePhrase);
            textsToCache.add(incorrectPhrase);
            
            // 2. Individual Letters (with "Letter " prefix for correct pronunciation)
            ALPHABET.forEach(l => textsToCache.add('Letter ' + l + '.'));

            const audioTexts = Array.from(textsToCache);
            totalAudios = audioTexts.length; // Total 29 assets
            
            // Start all fetch/cache operations in the background
            const fetchPromises = audioTexts.map(text => 
                fetchAndCacheAudio(text)
                    .catch(error => { 
                        // Log error, but proceed
                        console.error(`Failed background load for ${text}:`, error); 
                    })
                    .finally(() => { 
                        // CRITICAL FIX: Ensure the banner updates regardless of success/failure
                        updateLoadingBanner(); 
                    })
            );

            await Promise.allSettled(fetchPromises);
            
            console.log(`Background audio processing complete. Loaded: ${audiosLoaded}, Failed: ${failedAudioCount}`);
        };

        window.onload = function() {
            // Initial render, showing the start screen
            render(); 
            // Start the non-blocking prefetch immediately
            prefetchAllAudio();
        };

    </script>
</body>
</html>