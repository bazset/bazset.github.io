<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TERRY MPREG | Brain Damaged Games</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #333;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Start elements from the top */
        }

        /* Container for Score/Speed/Highscore Name */
        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-size: 12px;
            pointer-events: none;
            width: 100%;
            box-sizing: border-box;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        
        /* Container for the Double Jump Meter, centered */
        .hud-center-top {
            padding: 10px 0;
            width: 100%;
            display: flex;
            justify-content: center; /* Center the meter horizontally */
            pointer-events: none;
        }

        .hud-item {
            padding: 5px 10px;
        }
        
        /* Highscore Holder Styling */
        #highscore-holder {
            font-size: 10px;
            color: #ffcc00;
            text-align: center;
            width: 100%; /* Take full width on a new line */
            order: 3; /* Push it to the third row/position */
            margin-top: 10px;
        }

        /* Double Jump Label */
        .cooldown-label {
            color: white; 
            font-size: 8px;
            margin-right: 8px; 
            align-self: center;
            text-shadow: 2px 2px 0 #000;
        }

        /* Cooldown Bar */
        #jump-meter-container {
            width: 100px;
            height: 15px;
            background: #444;
            border: 2px solid #000;
            position: relative;
        }

        #jump-meter-fill {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            transition: width 0.1s linear, background-color 0.2s;
        }

        /* Menus */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            text-align: center;
            color: white;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 32px;
            color: #ffcc00;
            text-shadow: 4px 4px 0 #8b0000;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        h2 { font-size: 18px; color: #ff5555; margin-bottom: 30px; }
        
        button {
            background: #ff0000;
            border: 4px solid #fff;
            color: white;
            font-family: 'Press Start 2P', cursive; 
            font-size: 20px;
            padding: 15px 30px;
            cursor: pointer;
            box-shadow: 0 6px 0 #8b0000;
            margin: 10px;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            box-shadow: 0 2px 0 #8b0000;
            transform: translateY(4px);
        }

        input[type="text"] {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            padding: 10px;
            text-align: center;
            text-transform: uppercase;
            margin-bottom: 20px;
            width: 300px;
            max-width: 80%;
            border: 4px solid #fff;
            background: #000;
            color: #fff;
        }

        table {
            margin-top: 20px;
            border-collapse: collapse;
            width: 90%;
            max-width: 500px;
            background: rgba(0,0,0,0.8);
            border: 2px solid white;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #555;
            font-size: 12px;
        }
        th { color: #ffff00; }
        td:nth-child(2) { text-align: right; }

    </style>
    <!-- Load Supabase Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

    <!-- Audio Element for Music -->
    <audio id="bgm" loop>
        <source src="donnie.mp3" type="audio/mpeg">
    </audio>

    <div id="game-container" style="position: relative; width: 100%; height: 100vh;">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div class="hud-top">
                <div id="score-display" class="hud-item">SCORE: 0</div>
                <div id="speed-display" class="hud-item">SPD: 100%</div>
                <div id="highscore-holder">HIGHSCORE: LOADING...</div> <!-- New Highscore Display -->
            </div>
            
            <div class="hud-center-top">
                <div class="cooldown-label">DOUBLE JUMP</div>
                <div id="jump-meter-container">
                    <div id="jump-meter-fill"></div>
                </div>
            </div>

            <!-- Removed original hud-bottom -->
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="menu-screen">
            <h1>TERRY MPREG</h1>
            <p style="color:#aaa; font-size: 12px; margin-bottom: 20px;">BRAIN DAMAGED GAMES</p>
            <div style="font-size: 12px; line-height: 1.8; margin-bottom: 30px; max-width: 600px; padding: 0 20px;">
                TAP TO JUMP. DOUBLE TAP TO DOUBLE JUMP (BAR MUST BE FULL).<br>
                AVOID TOILETS, CUBES, AND HIGH BARRIERS!
            </div>
            <button id="start-btn">RUN TERRY RUN</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="menu-screen hidden">
            <h1 style="color: #ff5555;">TERRY'S WATER BROKE!</h1>
            <p id="final-score">SCORE: 0</p>
            
            <!-- Message for non-top-10 scores -->
            <p id="top-ten-message" class="hidden" style="color:#00ff00; margin-bottom: 20px; font-size: 14px; max-width: 80%;">
                A noble attempt! Only the top 10 are recorded.
            </p>

            <!-- Score submission form (only visible if player made the cut) -->
            <div id="high-score-form" class="hidden">
                <p>YOU MADE THE TOP 10! ENTER NAME (MAX 10):</p>
                <input type="text" id="player-name" maxlength="10" placeholder="YOUR NAME">
                <br>
                <button id="submit-score-btn">SUBMIT</button>
            </div>

            <div id="leaderboard-container" class="hidden">
                <p style="color: #00ff00;">TOP 10 SURVIVORS</p>
                <table id="leaderboard-table">
                    <thead><tr><th>NAME</th><th>SCORE</th></tr></thead>
                    <tbody id="leaderboard-body"></tbody>
                </table>
                <button id="restart-btn" style="margin-top: 20px;">PLAY AGAIN</button>
            </div>
        </div>
    </div>

    <script type="module">
        // --- SUPABASE CONFIGURATION ---
        const SUPABASE_URL = 'https://xybyjldasdstkvpagmdk.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_5_B_Oh3Pcr-dppdUoxpGeg_oqRYKlCK';
        const TABLE_NAME = 'Highscores';
        const GAME_NAME = 'TERRY MPREG';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

        /**
         * Function to save the score to the Supabase Highscores table.
         */
        async function saveScore(name, score) {
            try {
                const { error } = await supabaseClient
                    .from(TABLE_NAME)
                    .insert([
                        { 
                            name: name.toUpperCase(), 
                            score: score, 
                            gamename: GAME_NAME 
                        }
                    ]);

                if (error) {
                    console.error('Supabase insert error:', error);
                    return false;
                }
                return true;
            } catch (e) {
                console.error('Save score exception:', e);
                return false;
            }
        }

        /**
         * Function to fetch the top 10 scores from the Supabase Highscores table.
         * Returns the raw data array.
         */
        async function fetchLeaderboard() {
            try {
                const { data, error } = await supabaseClient
                    .from(TABLE_NAME)
                    .select('name, score')
                    .eq('gamename', GAME_NAME) // Filter for this specific game
                    .order('score', { ascending: false }) // Sort by score, highest first
                    .limit(10); // Only fetch the top 10

                if (error) {
                    console.error('Supabase fetch error:', error);
                    return [];
                }
                return data || [];
            } catch (e) {
                console.error('Fetch leaderboard exception:', e);
                return [];
            }
        }

        /**
         * Checks if the current score is high enough to enter the top 10.
         * @param {number} currentScore - The player's score.
         * @returns {Promise<boolean>} - True if the score is in the top 10, false otherwise.
         */
        async function checkIfTopTen(currentScore) {
            const scores = await fetchLeaderboard();
            
            // If the leaderboard has fewer than 10 entries, the score is always in the top 10.
            if (scores.length < 10) return true;
            
            // If the current score is greater than the lowest score in the top 10 (index 9), it makes the cut.
            const lowestTopScore = scores[9].score; 
            return currentScore > lowestTopScore;
        }


        // --- GAME ENGINE ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        ctx.imageSmoothingEnabled = false;
        
        let width, height;
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            ctx.imageSmoothingEnabled = false; 
        }
        window.addEventListener('resize', resize);
        resize();

        // --- AUDIO SYSTEM (Web Audio API for SFX, HTML Audio for BGM) ---
        let audioCtx;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            console.warn("AudioContext not supported or blocked");
        }
        
        const playSound = (type) => {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.log(e));
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'jump') {
                // "Fart" sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'doubleJump') {
                // "Puff" sound
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'death') {
                // Scream/Crash
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 1.0);
                
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 50;
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 500;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(now);
                lfo.stop(now + 1.0);

                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            }
        };

        // --- ASSET GENERATION (Procedural Pixel Art) ---
        
        // Reduced default pixelSize to 3 for smaller sprites
        function createPixelSprite(pixelMap, colorMap, pixelSize = 3) { 
            const h = pixelMap.length;
            const w = pixelMap[0].length;
            const c = document.createElement('canvas');
            c.width = w * pixelSize;
            c.height = h * pixelSize;
            const xCtx = c.getContext('2d');
            
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const char = pixelMap[y][x];
                    if(char !== ' ' && colorMap[char]) {
                        xCtx.fillStyle = colorMap[char];
                        xCtx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            return c;
        }

        // Color map updated for cheese
        const C = {
            R: '#cc0000', // Red Shirt
            B: '#2244aa', // Blue Jeans
            S: '#ffccaa', // Skin
            H: '#442200', // Hair/Shoes
            W: '#ffffff', // White
            G: '#888888', // Grey
            D: '#553311', // Dark Brown (Wood)
            L: '#885522', // Light Brown (Wood)
            K: '#000000', // Black outline
            Y: '#ffff00', // Yellow Cheese
            O: '#ff8800'  // Orange rind/holes
        };

        const terryMap = [
            "  HHH     ",
            " HSSSS    ",
            " HSSHS    ",
            "  SSSS    ",
            "  RRRRR   ",
            " SRRRRRR  ", // Belly bulge
            " SRRRRRR  ",
            " SBBBB    ",
            "  BBBB    ",
            "  B  B    ",
            "  B  B    ",
            " HH  HH   "
        ];
        
        const toiletMap = [
            "    WW    ",
            "   WWWWG  ",
            "   WWWWG  ",
            "  WWWWWW  ",
            " WWWWWWWW ",
            " WW    WW ",
            "  WW  WW  ",
            "  WWWWWW  "
        ];

        const blockMap = [
            "DDDDDDDD",
            "DLLLLLLD",
            "DL DDDLD",
            "DL DDDLD",
            "DLDDD LD",
            "DLDDD LD",
            "DLLLLLLD",
            "DDDDDDDD"
        ];
        
        const cheeseMap = [
            "YYYYYYY ",
            "Y O Y OY",
            "YYYYYYYY",
            "OY Y Y O",
            "YYYYYYYY",
            "Y O Y OY",
            " YYYYYY "
        ];

        // Sprites object updated with new, smaller sprites (4 instead of 6 for obstacles, 3 instead of 4 for terry)
        const sprites = {
            terry: createPixelSprite(terryMap, C, 3),   // 30x36 px (was 40x48)
            toilet: createPixelSprite(toiletMap, C, 4), // 40x32 px (was 60x48)
            block: createPixelSprite(blockMap, C, 4),    // 32x32 px (was 48x48)
            cheese: createPixelSprite(cheeseMap, C, 4)   // 28x28 px (was 42x42)
        };
        
        // --- GAME LOGIC ---

        const STATE = { MENU: 0, PLAY: 1, DEAD: 2 };
        let gameState = STATE.MENU;
        let score = 0;
        let gameSpeed = 400; 
        let timeSinceStart = 0;
        let lastTime = 0;
        
        // Background constants for seamless looping
        const MOUNTAIN_WIDTH = 400; 
        const TREE_CLUSTER_WIDTH = 600;
        
        // Player properties adjusted for smaller sprite
        const player = {
            x: 100,
            y: 0,
            width: 30, // New width
            height: 36, // New height
            vy: 0,
            grounded: false,
            jumpForce: -600, // Adjusted jump force
            doubleJumpForce: -450, // Adjusted double jump force
            gravity: 1800, // Adjusted gravity
            jumps: 0,
            cooldown: 100, 
            maxCooldown: 100,
        };
        
        // Ground Y position ADJUSTED TO 120px from bottom for more central view
        const GROUND_HEIGHT = 120; 

        let obstacles = [];
        let particles = [];
        let screenShake = 0;
        let topScoreHolder = 'NONE'; // State for highscore name

        function resetGame() {
            player.y = height - GROUND_HEIGHT - player.height;
            player.vy = 0;
            player.cooldown = 100;
            player.jumps = 0;
            
            obstacles = [];
            particles = [];
            
            score = 0;
            gameSpeed = 400;
            timeSinceStart = 0;
            
            document.getElementById('score-display').innerText = `SCORE: 0`;
            document.getElementById('speed-display').innerText = `SPD: 100%`;
            updateStaminaUI();
        }

        // Obstacle spawning updated to include less frequent highBarrier
        function spawnObstacle() {
            const obstacleTypes = ['block', 'toilet', 'cheese', 'highBarrier'];
            
            // Increased chance of spawning a high barrier (1/10 chance)
            let type = 'block'; // Default
            const r = Math.random();
            if (r < 0.4) { // 40% chance for block
                type = 'block';
            } else if (r < 0.65) { // 25% chance for toilet
                type = 'toilet';
            } else if (r < 0.90) { // 25% chance for cheese
                type = 'cheese';
            } else { // 10% chance for highBarrier (UPPED FROM 5%)
                type = 'highBarrier';
            }
            
            let obs = {
                x: width + 50,
                y: 0, 
                width: 0, 
                height: 0,
                type: type,
                passed: false,
                speedFactor: 1.0 
            };

            const groundY = height - GROUND_HEIGHT;
            const blockHeight = sprites.block.height; // New base block height
            const cheeseHeight = sprites.cheese.height;

            if (type === 'block') {
                obs.width = sprites.block.width;
                obs.height = blockHeight;
                // Random chance for a two-block stack
                if (Math.random() > 0.8) { 
                    obs.height = blockHeight * 2;
                    obs.y = groundY - obs.height;
                } else {
                    obs.y = groundY - obs.height;
                }
                obs.speedFactor = 0.9 + Math.random() * 0.1; 
            } else if (type === 'toilet') {
                obs.width = sprites.toilet.width;
                obs.height = sprites.toilet.height; 
                obs.y = groundY - obs.height;
                obs.speedFactor = 1.0; 
            } else if (type === 'cheese') {
                obs.width = sprites.cheese.width;
                obs.height = cheeseHeight; 
                obs.y = groundY - obs.height;
                obs.speedFactor = 1.2 + Math.random() * 0.2; 
            } else if (type === 'highBarrier') {
                // Tall barrier (3 blocks high)
                obs.width = blockHeight; 
                obs.height = blockHeight * 3;
                obs.y = groundY - obs.height;
                obs.speedFactor = 0.8; 
            }

            obstacles.push(obs);
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 300,
                    vy: (Math.random() - 0.5) * 300,
                    life: 0.5,
                    color: color
                });
            }
        }

        function update(dt) {
            if (gameState !== STATE.PLAY) return;

            timeSinceStart += dt;
            
            const speedMultiplier = 1 + Math.floor(timeSinceStart / 5) * 0.05;
            const currentSpeed = gameSpeed * speedMultiplier;
            
            score += (currentSpeed * dt) / 10;
            document.getElementById('score-display').innerText = `SCORE: ${Math.floor(score)}`;
            document.getElementById('speed-display').innerText = `SPD: ${Math.floor(speedMultiplier * 100)}%`;

            // Cooldown Refill
            if (player.cooldown < player.maxCooldown) {
                player.cooldown += 40 * dt; 
                if(player.cooldown > player.maxCooldown) player.cooldown = player.maxCooldown;
                updateStaminaUI();
            }

            // Physics
            player.vy += player.gravity * dt;
            player.y += player.vy * dt;

            // Ground collision
            const groundY = height - GROUND_HEIGHT; // Use new constant
            if (player.y + player.height > groundY) {
                player.y = groundY - player.height;
                player.vy = 0;
                player.grounded = true;
                player.jumps = 0;
            } else {
                player.grounded = false;
            }

            // Obstacles - Adjusted spawn range
            const spawnDistance = 200 + Math.random() * 200; // Wider spawn range for more space
            let lastObsX = obstacles.length > 0 ? obstacles[obstacles.length-1].x : width;
            
            // Increased spawn chance, but with wider spacing allowed
            if (width - lastObsX > spawnDistance) {
                if (Math.random() < 0.1) spawnObstacle(); // Adjusted spawn check
            }
            if (obstacles.length === 0) spawnObstacle();

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                
                // --- Use individual speed factor for movement ---
                ob.x -= currentSpeed * ob.speedFactor * dt; 
                // --------------------------------------------------

                // Collision Detection - Removed 10px buffer for accurate bounding box
                if (
                    player.x < ob.x + ob.width && // player left edge before obstacle right edge
                    player.x + player.width > ob.x && // player right edge after obstacle left edge
                    player.y < ob.y + ob.height && // player top edge before obstacle bottom edge
                    player.y + player.height > ob.y // player bottom edge after obstacle top edge
                ) {
                    die();
                }

                if (ob.x + ob.width < 0) {
                    obstacles.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= dt;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        async function die() { // Now async to await database check
            gameState = STATE.DEAD;
            playSound('death');
            
            // Stop Music
            const bgm = document.getElementById('bgm');
            if(bgm) {
                bgm.pause();
                bgm.currentTime = 0;
            }

            screenShake = 0.5; 
            const finalScore = Math.floor(score);
            document.getElementById('final-score').innerText = `SCORE: ${finalScore}`;
            document.getElementById('game-over-screen').classList.remove('hidden');

            // --- New Logic: Check if score is high enough for the leaderboard ---
            const madeTopTen = await checkIfTopTen(finalScore);

            if (madeTopTen) {
                // Made the top 10: Show the submission form
                document.getElementById('top-ten-message').classList.add('hidden'); 
                document.getElementById('high-score-form').classList.remove('hidden'); 
                document.getElementById('leaderboard-container').classList.add('hidden');
                
                // Reset the submit button state
                const submitBtn = document.getElementById('submit-score-btn');
                submitBtn.disabled = false;
                submitBtn.innerText = "SUBMIT";
            } else {
                // Did NOT make the top 10: Show message and leaderboard immediately
                document.getElementById('top-ten-message').classList.remove('hidden'); 
                document.getElementById('high-score-form').classList.add('hidden'); 
                document.getElementById('leaderboard-container').classList.remove('hidden'); 
                refreshLeaderboard(); // Populate the board right away
            }
            // -------------------------------------------------------------------
        }

        function jump() {
            if (gameState !== STATE.PLAY) return;

            if (player.grounded) {
                player.vy = player.jumpForce;
                player.jumps = 1;
                player.grounded = false;
                playSound('jump');
                createParticles(player.x + player.width/2, player.y + player.height, '#fff', 5);
            } else if (player.jumps === 1 && player.cooldown >= player.maxCooldown) {
                // Double jump ONLY if cooldown is full
                player.vy = player.doubleJumpForce;
                player.jumps = 2;
                player.cooldown = 0; // Empty bar completely
                updateStaminaUI();
                playSound('doubleJump');
                createParticles(player.x + player.width/2, player.y + player.height, '#00ff00', 10);
            }
        }

        function updateStaminaUI() {
            const bar = document.getElementById('jump-meter-fill');
            bar.style.width = `${player.cooldown}%`;
            // Red when empty/filling, Green when ready
            bar.style.backgroundColor = player.cooldown >= player.maxCooldown ? '#00ff00' : '#ff0000';
        }

        // --- BACKGROUND RENDERING UTILS ---
        
        // Helper function for drawing seamless, repeating background elements
        function drawRepeatingBackground(drawFunc, speed, tileWidth, floorY) {
            const offset = (timeSinceStart * speed) % tileWidth;
            let x = -offset;
            // Draw tiles until the screen is covered
            while (x < width) {
                drawFunc(ctx, x, floorY);
                x += tileWidth;
            }
        }

        // Draw a single mountain tile
        function drawVoxelMountain(c, x, floorY) {
            c.fillStyle = '#551A8B'; 
            const size = 30; // Reduced size
            for (let r = 0; r < 5; r++) {
                for (let cx = 0; cx <= r; cx++) {
                    let px = x + 150 + (cx * size) - (r * size / 2); // Adjusted position
                    let py = floorY - 150 + (r * size); // Adjusted position
                    c.fillRect(px, py, size, size);
                }
            }
        }

        // Draw a single tree cluster tile
        function drawVoxelTree(c, x, floorY) {
            // Tree 1 (Smaller)
            c.fillStyle = '#553311';
            c.fillRect(x + 40, floorY - 45, 15, 45);
            c.fillStyle = '#228822';
            c.fillRect(x + 15, floorY - 75, 75, 30); 
            c.fillRect(x + 30, floorY - 95, 30, 20); 
            
            // Tree 2 (further back, smaller)
            c.fillStyle = '#553311';
            c.fillRect(x + 250, floorY - 30, 10, 30);
            c.fillStyle = '#228822';
            c.fillRect(x + 230, floorY - 60, 50, 25); 
            c.fillRect(x + 240, floorY - 75, 25, 15); 
        }

        // --- RENDER ---

        function draw() {
            // Screen Shake must be applied before drawing starts
            if (screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * 20;
                const shakeY = (Math.random() - 0.5) * 20;
                canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
            } else {
                canvas.style.transform = `none`;
            }

            // Sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, width, height);
            
            // Mountains 
            drawRepeatingBackground(drawVoxelMountain, 20, MOUNTAIN_WIDTH, height - GROUND_HEIGHT);

            // Trees 
            drawRepeatingBackground(drawVoxelTree, 150, TREE_CLUSTER_WIDTH, height - GROUND_HEIGHT);

            // Ground (Uses new constant)
            ctx.fillStyle = '#44aa44'; // Green grass/top layer
            ctx.fillRect(0, height - GROUND_HEIGHT, width, GROUND_HEIGHT);
            ctx.fillStyle = '#553311'; // Brown dirt/bottom layer (now thicker)
            // Adjust the fill height to be based on the new GROUND_HEIGHT
            ctx.fillRect(0, height - GROUND_HEIGHT * 0.7, width, GROUND_HEIGHT * 0.7); 

            // Obstacles
            obstacles.forEach(ob => {
                if (ob.type === 'block' || ob.type === 'highBarrier') {
                    // Draw multiple blocks for tall structures (highBarrier)
                    const blockSprite = sprites.block;
                    let currentY = ob.y;
                    while (currentY < ob.y + ob.height) {
                        ctx.drawImage(blockSprite, ob.x, currentY);
                        currentY += blockSprite.height;
                    }
                } else if (ob.type === 'toilet') {
                    ctx.drawImage(sprites.toilet, ob.x, ob.y);
                } else if (ob.type === 'cheese') {
                    ctx.drawImage(sprites.cheese, ob.x, ob.y);
                }
            });

            // Player
            let bob = 0;
            if (gameState === STATE.PLAY && player.grounded) {
                bob = Math.sin(timeSinceStart * 20) * 2;
            }
            
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            if (!player.grounded) {
                // Reduced rotation on jump to look better on smaller sprite
                ctx.rotate(Math.min(Math.PI/6, player.vy * 0.001)); 
            }
            ctx.drawImage(sprites.terry, -player.width/2, -player.height/2 + bob);
            ctx.restore();

            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
            });
        }

        function loop(timestamp) {
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            if (dt > 0.1) dt = 0.1; 

            if (screenShake > 0) screenShake -= dt;

            update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        // --- INPUTS ---
        
        function handleInput(e) {
            // Prevent default touch/click behavior if it wasn't on a UI element
            if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
                 if (e.type === 'touchstart') e.preventDefault();
            }
            
            if (gameState === STATE.PLAY) {
                jump();
            }
        }

        const startBtn = document.getElementById('start-btn');
        if(startBtn) startBtn.addEventListener('click', startGame);

        const restartBtn = document.getElementById('restart-btn');
        if(restartBtn) restartBtn.addEventListener('click', () => {
             document.getElementById('game-over-screen').classList.add('hidden');
             startGame();
        });

        const submitBtn = document.getElementById('submit-score-btn');
        if(submitBtn) submitBtn.addEventListener('click', submitScore);
        
        // Use document for general input handling when game is active
        window.addEventListener('mousedown', (e) => {
            // Only respond to clicks outside of the menu buttons/inputs
            if (gameState === STATE.PLAY) {
                handleInput(e);
            }
        });
        window.addEventListener('touchstart', (e) => {
            // Only respond to touches outside of the menu buttons/inputs
            if (gameState === STATE.PLAY) {
                 handleInput(e);
            }
        }, {passive: false});

        async function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            gameState = STATE.PLAY;
            resetGame();
            
            // Resume/Start AudioContext on first user interaction
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(e => {});
            
            // Start Music
            const bgm = document.getElementById('bgm');
            if(bgm) {
                bgm.currentTime = 0;
                bgm.play().catch(e => console.log("Music play blocked:", e));
            }
            
            // Re-fetch leaderboard to update highscore holder on start
            await refreshLeaderboard(true); 
        }

        // Updated submitScore to use Promise.race for a 5-second timeout
        async function submitScore() {
            const name = document.getElementById('player-name').value.trim() || "UNK";
            const btn = document.getElementById('submit-score-btn');
            
            btn.disabled = true;
            btn.innerText = "SAVING...";

            // Create a promise that resolves to 'false' after 5 seconds (the timeout)
            const timeoutPromise = new Promise(resolve => 
                setTimeout(() => resolve(false), 5000)
            );
            
            let success = false;
            try {
                // Race the score submission against the timeout
                const scorePromise = saveScore(name, Math.floor(score));
                success = await Promise.race([scorePromise, timeoutPromise]);
            } catch (e) {
                // If there's an unexpected error during the submission process
                console.error("Submission promise failed:", e);
                success = false;
            }
            
            // After submission, hide the form and show the leaderboard
            document.getElementById('high-score-form').classList.add('hidden');
            document.getElementById('leaderboard-container').classList.remove('hidden');
            
            if (success) {
                refreshLeaderboard(false); // Update leaderboard list
            } else {
                 // If submission failed, show the board, but notify the user
                 const tbody = document.getElementById('leaderboard-body');
                 tbody.innerHTML = '<tr><td colspan="2" style="color:#ff0000;">SAVE FAILED. VIEWING CURRENT LEADERBOARD.</td></tr>';
                 refreshLeaderboard(false);
            }
        }

        async function refreshLeaderboard(updateTopHolder = true) {
            const tbody = document.getElementById('leaderboard-body');
            // Don't show loading on screen if we are just fetching the top holder
            if (!updateTopHolder) { 
                tbody.innerHTML = '<tr><td colspan="2">LOADING...</td></tr>';
            }
            
            const scores = await fetchLeaderboard(); 
            
            if (updateTopHolder) {
                const holderText = scores.length > 0 
                    ? `HIGHSCORE: ${scores[0].name} (${scores[0].score})`
                    : 'HIGHSCORE: BE THE FIRST!';
                document.getElementById('highscore-holder').innerText = holderText;
            }

            // Only update the table body if we are on the game over screen
            if (!updateTopHolder) {
                tbody.innerHTML = '';
                scores.forEach((s, index) => {
                    const tr = document.createElement('tr');
                    // Highlight the top score
                    if (index === 0) tr.style.color = '#ffff00'; 
                    tr.innerHTML = `<td>${s.name}</td><td>${s.score}</td>`;
                    tbody.appendChild(tr);
                });
                
                if (scores.length === 0) {
                     tbody.innerHTML = '<tr><td colspan="2">NO SCORES YET</td></tr>';
                }
            }
        }

        // Initialize the game loop
        lastTime = performance.now();
        requestAnimationFrame(loop);

        // Populate the mock leaderboard and get the initial highscore holder on load
        refreshLeaderboard();
    </script>
</body>
</html>