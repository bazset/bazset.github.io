<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TERRY MPREG | Brain Damaged Games</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #333;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Start elements from the top */
            margin-top: 5vh; 
        }

        /* Container for ALL Top HUD elements (Score, Speed, Jump Bar, Highscore) */
        .hud-top {
            padding: 20px;
            display: flex;
            /* MODIFICATION: Align items vertically in the center */
            justify-content: space-between;
            align-items: center; 
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-size: 12px;
            pointer-events: none;
            width: 100%;
            box-sizing: border-box;
            flex-wrap: wrap; 
        }
        
        /* Highscore Holder Styling */
        #highscore-holder {
            font-size: 10px;
            color: #ffcc00;
            text-align: center;
            width: 100%; /* Take full width on a new line */
            order: 3; /* Push it to the third row/position */
            margin-top: 10px;
        }

        /* Double Jump Label */
        .cooldown-label {
            color: white; 
            font-size: 8px;
            margin-right: 8px; 
            align-self: center;
            text-shadow: 2px 2px 0 #000;
        }

        /* Cooldown Bar */
        #jump-meter-container {
            width: 100px;
            height: 15px;
            background: #444;
            border: 2px solid #000;
            position: relative;
        }

        #jump-meter-fill {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            transition: width 0.1s linear, background-color 0.2s;
        }

        /* Menus */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            text-align: center;
            color: white;
            z-index: 10;
            overflow-y: auto; /* IMPORTANT: Allows scrolling for tall content like leaderboards */
            padding: 20px 0; /* Add padding for scroll room */
            box-sizing: border-box;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 32px;
            color: #ffcc00;
            text-shadow: 4px 4px 0 #8b0000;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        h2 { font-size: 18px; color: #ff5555; margin-bottom: 30px; }
        
        button {
            background: #ff0000;
            border: 4px solid #fff;
            color: white;
            /* FIX: Corrected font name for blocky look */
            font-family: 'Press Start 2P', cursive; 
            font-size: 20px;
            padding: 15px 30px;
            cursor: pointer;
            box-shadow: 0 6px 0 #8b0000;
            margin: 10px 10px 20px; /* Increased bottom margin */
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            box-shadow: 0 2px 0 #8b0000;
            transform: translateY(4px);
        }

        input[type="text"] {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            padding: 10px;
            text-align: center;
            text-transform: uppercase;
            margin-bottom: 20px;
            width: 300px;
            max-width: 80%;
            border: 4px solid #fff;
            background: #000;
            color: #fff;
        }

        table {
            /* MODIFICATION: Centered the table and increased max width to 350px to fit names */
            margin: 20px auto; 
            border-collapse: collapse;
            width: 70%;
            max-width: 350px; 
            background: rgba(0,0,0,0.8);
            border: 2px solid white;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #555;
            /* Font Size: Kept at 8px */
            font-size: 8px;
        }
        th { color: #ffff00; }
        td:nth-child(2) { text-align: right; }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

    <audio id="bgm" loop>
        <source src="donnie.mp3" type="audio/mpeg">
    </audio>

    <div id="game-container" style="position: relative; width: 100%; height: 100vh;">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div class="hud-top">
                <div class="hud-group" style="display: flex; gap: 20px;">
                    <div id="score-display" class="hud-item">SCORE: 0</div>
                    <div id="speed-display" class="hud-item">SPD: 100%</div>
                </div>
                
                <div class="hud-group" style="display: flex;">
                    <div class="cooldown-label">DOUBLE JUMP</div>
                    <div id="jump-meter-container">
                        <div id="jump-meter-fill"></div>
                    </div>
                </div>

                <div id="highscore-holder">HIGHSCORE: LOADING...</div> 
            </div>
            
            </div>

        <div id="start-screen" class="menu-screen">
            <h1>TERRY MPREG</h1>
            <p style="color:#aaa; font-size: 12px; margin-bottom: 20px;">BRAIN DAMAGED GAMES</p>
            <div style="font-size: 12px; line-height: 1.8; margin-bottom: 30px; max-width: 600px; padding: 0 20px;">
                TAP TO JUMP. TAP AGAIN TO DOUBLE JUMP (BAR MUST BE FULL).<br>
                AVOID TOILETS, CUBES, AND HIGH BARRIERS!
            </div>
            <button id="start-btn">RUN TERRY RUN</button>

            <div id="start-leaderboard-container">
                <p style="color: #00ff00; margin-top: 10px;">TOP 10 SURVIVORS</p>
                <table id="start-leaderboard-table">
                    <thead><tr><th>NAME</th><th>SCORE</th></tr></thead>
                    <tbody id="start-leaderboard-body">
                        </tbody>
                </table>
            </div>
        </div>

        <div id="game-over-screen" class="menu-screen hidden">
            <h1 style="color: #ff5555;">TERRY'S WATER BROKE!</h1>
            <p id="final-score">SCORE: 0</p>
            
            <div id="high-score-form" class="hidden">
                <p>YOU MADE THE TOP 10! ENTER NAME (MAX 10):</p>
                <input type="text" id="player-name" maxlength="10" placeholder="YOUR NAME">
                <br>
                <button id="submit-score-btn">SUBMIT</button>
            </div>
            
            <button id="restart-btn">PLAY AGAIN</button>

            <div id="gameover-leaderboard-container" class="hidden">
                <p style="color: #00ff00; margin-top: 10px;">TOP 10 SURVIVORS</p>
                <table id="gameover-leaderboard-table">
                    <thead><tr><th>NAME</th><th>SCORE</th></tr></thead>
                    <tbody id="gameover-leaderboard-body"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script type="module">
        // --- SUPABASE CONFIGURATION ---
        const SUPABASE_URL = 'https://xybyjldasdstkvpagmdk.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_5_B_Oh3Pcr-dppdUoxpGeg_oqRYKlCK';
        const TABLE_NAME = 'Highscores';
        const GAME_NAME = 'TERRY MPREG';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

        /**
         * Function to save the score to the Supabase Highscores table.
         */
        async function saveScore(name, score) {
            try {
                const { error } = await supabaseClient
                    .from(TABLE_NAME)
                    .insert([
                        { 
                            name: name.toUpperCase(), 
                            score: score, 
                            gamename: GAME_NAME 
                        }
                    ]);

                if (error) {
                    console.error('Supabase insert error:', error);
                    return false;
                }
                return true;
            } catch (e) {
                console.error('Save score exception:', e);
                return false;
            }
        }

        /**
         * Function to fetch the top 10 scores from the Supabase Highscores table.
         * Returns the raw data array.
         */
        async function fetchLeaderboard() {
            try {
                const { data, error } = await supabaseClient
                    .from(TABLE_NAME)
                    .select('name, score')
                    .eq('gamename', GAME_NAME) // Filter for this specific game
                    .order('score', { ascending: false }) // Sort by score, highest first
                    .limit(10); // Only fetch the top 10

                if (error) {
                    console.error('Supabase fetch error:', error);
                    return [];
                }
                return data || [];
            } catch (e) {
                console.error('Fetch leaderboard exception:', e);
                return [];
            }
        }

        /**
         * Checks if the current score is high enough to enter the top 10.
         * @param {number} currentScore - The player's score.
         * @returns {Promise<boolean>} - True if the score is in the top 10, false otherwise.
         */
        async function checkIfTopTen(currentScore) {
            const scores = await fetchLeaderboard();
            
            // If the leaderboard has fewer than 10 entries, the score is always in the top 10.
            if (scores.length < 10) return true;
            
            // If the current score is greater than the lowest score in the top 10 (index 9), it makes the cut.
            const lowestTopScore = scores[9].score; 
            return currentScore > lowestTopScore;
        }


        // --- GAME ENGINE ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        ctx.imageSmoothingEnabled = false;
        
        let width, height;
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            ctx.imageSmoothingEnabled = false; 
        }
        window.addEventListener('resize', resize);
        resize();

        // --- AUDIO SYSTEM (Web Audio API for SFX, HTML Audio for BGM) ---
        let audioCtx;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            console.warn("AudioContext not supported or blocked");
        }
        
        const playSound = (type) => {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.log(e));
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'jump') {
                // "Fart" sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'doubleJump') {
                // "Puff" sound
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'death') {
                // Scream/Crash
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 1.0);
                
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 50;
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 500;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(now);
                lfo.stop(now + 1.0);

                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            }
        };

        // --- ASSET GENERATION (Procedural Pixel Art) ---
        
        // Reduced default pixelSize to 3 for smaller sprites
        function createPixelSprite(pixelMap, colorMap, pixelSize = 3) { 
            const h = pixelMap.length;
            const w = pixelMap[0].length;
            const c = document.createElement('canvas');
            c.width = w * pixelSize;
            c.height = h * pixelSize;
            const xCtx = c.getContext('2d');
            
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const char = pixelMap[y][x];
                    if(char !== ' ' && colorMap[char]) {
                        xCtx.fillStyle = colorMap[char];
                        xCtx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            return c;
        }

        // Color map updated for cheese
        const C = {
            R: '#cc0000', // Red Shirt
            B: '#2244aa', // Blue Jeans
            S: '#ffccaa', // Skin
            H: '#442200', // Hair/Shoes
            W: '#ffffff', // White
            G: '#888888', // Grey
            D: '#553311', // Dark Brown (Wood)
            L: '#885522', // Light Brown (Wood)
            K: '#000000', // Black outline
            Y: '#ffff00', // Yellow Cheese
            O: '#ff8800'  // Orange rind/holes
        };

        const terryMap = [
            "  HHH     ",
            " HSSSS    ",
            " HSSHS    ",
            "  SSSS    ",
            "  RRRRR   ",
            " SRRRRRR  ", // Belly bulge
            " SRRRRRR  ",
            " SBBBB    ",
            "  BBBB    ",
            "  B  B    ",
            "  B  B    ",
            " HH  HH   "
        ];
        
        const toiletMap = [
            "    WW    ",
            "   WWWWG  ",
            "   WWWWG  ",
            "  WWWWWW  ",
            " WWWWWWWW ",
            " WW    WW ",
            "  WW  WW  ",
            "  WWWWWW  "
        ];

        const blockMap = [
            "DDDDDDDD",
            "DLLLLLLD",
            "DL DDDLD",
            "DL DDDLD",
            "DLDDD LD",
            "DLDDD LD",
            "DLLLLLLD",
            "DDDDDDDD"
        ];
        
        const cheeseMap = [
            "YYYYYYY ",
            "Y O Y OY",
            "YYYYYYYY",
            "OY Y Y O",
            "YYYYYYYY",
            "Y O Y OY",
            " YYYYYY "
        ];

        // Sprites object updated with new, smaller sprites (4 instead of 6 for obstacles, 3 instead of 4 for terry)
        const sprites = {
            terry: createPixelSprite(terryMap, C, 3),   // 30x36 px (was 40x48)
            toilet: createPixelSprite(toiletMap, C, 4), // 40x32 px (was 60x48)
            block: createPixelSprite(blockMap, C, 4),    // 32x32 px (was 48x48)
            cheese: createPixelSprite(cheeseMap, C, 4)   // 28x28 px (was 42x42)
        };
        
        // --- GAME LOGIC ---

        const STATE = { MENU: 0, PLAY: 1, DEAD: 2 };
        let gameState = STATE.MENU;
        let score = 0;
        let gameSpeed = 400; 
        let timeSinceStart = 0;
        let lastTime = 0;
        
        // Background constants for seamless looping
        const MOUNTAIN_WIDTH = 400; 
        const TREE_CLUSTER_WIDTH = 600;
        
        // Player properties adjusted for smaller sprite
        const player = {
            x: 100,
            y: 0,
            width: 30, // New width
            height: 36, // New height
            vy: 0,
            grounded: false,
            jumpForce: -600, // Adjusted jump force
            doubleJumpForce: -450, // Adjusted double jump force
            gravity: 1800, // Adjusted gravity
            jumps: 0,
            cooldown: 100,
            maxCooldown: 100,
        };

        // Ground Y position ADJUSTED TO 120px from bottom for more central view
        const GROUND_HEIGHT = 120;
        let obstacles = [];
        let particles = [];
        let screenShake = 0;
        let topScoreHolder = 'NONE'; // State for highscore name
        
        function resetGame() {
            player.y = height - GROUND_HEIGHT - player.height;
            player.vy = 0;
            player.cooldown = 100;
            player.jumps = 0;
            obstacles = [];
            particles = [];
            score = 0;
            gameSpeed = 400;
            timeSinceStart = 0;
            document.getElementById('score-display').innerText = `SCORE: 0`;
            document.getElementById('speed-display').innerText = `SPD: 100%`;
            updateStaminaUI();
        }

        // Obstacle spawning updated to include less frequent highBarrier
        function spawnObstacle() {
            const obstacleTypes = ['block', 'toilet', 'cheese', 'highBarrier']; // Increased chance of spawning a high barrier (1/10 chance)
            let type = 'block'; // Default

            const r = Math.random();
            if (r < 0.4) { // 40% chance for block
                type = 'block';
            } else if (r < 0.65) { // 25% chance for toilet
                type = 'toilet';
            } else if (r < 0.90) { // 25% chance for cheese
                type = 'cheese';
            } else { // 10% chance for highBarrier (UPPED FROM 5%)
                type = 'highBarrier';
            }

            let obs = {
                x: width + 50,
                y: 0,
                width: 0,
                height: 0,
                type: type,
                passed: false,
                speedFactor: 1.0
            };

            const groundY = height - GROUND_HEIGHT;
            const blockHeight = sprites.block.height; // New base block height
            const cheeseHeight = sprites.cheese.height;

            if (type === 'block') {
                obs.width = sprites.block.width;
                obs.height = blockHeight;
                // Random chance for a two-block stack
                if (Math.random() > 0.8) {
                    obs.height = blockHeight * 2;
                    obs.y = groundY - obs.height;
                } else {
                    obs.y = groundY - obs.height;
                }
                obs.speedFactor = 0.9 + Math.random() * 0.1;
            } else if (type === 'toilet') {
                obs.width = sprites.toilet.width;
                obs.height = sprites.toilet.height;
                obs.y = groundY - obs.height;
                obs.speedFactor = 1.0;
            } else if (type === 'cheese') {
                obs.width = sprites.cheese.width;
                obs.height = cheeseHeight;
                obs.y = groundY - obs.height;
                obs.speedFactor = 1.2 + Math.random() * 0.2;
            } else if (type === 'highBarrier') {
                // Tall barrier (3 blocks high)
                obs.width = blockHeight;
                obs.height = blockHeight * 3;
                obs.y = groundY - obs.height;
                obs.speedFactor = 0.8;
            }

            obstacles.push(obs);
        }

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 300,
                    vy: (Math.random() - 0.5) * 300,
                    life: 0.5,
                    color: color
                });
            }
        }

        function update(dt) {
            if (gameState !== STATE.PLAY) return;

            timeSinceStart += dt;
            const speedMultiplier = 1 + Math.floor(timeSinceStart / 5) * 0.05;
            const currentSpeed = gameSpeed * speedMultiplier;

            score += (currentSpeed * dt) / 10;

            document.getElementById('score-display').innerText = `SCORE: ${Math.floor(score)}`;
            document.getElementById('speed-display').innerText = `SPD: ${Math.floor(speedMultiplier * 100)}%`;


            // Cooldown Refill
            if (player.cooldown < player.maxCooldown) {
                player.cooldown += 40 * dt;
                if(player.cooldown > player.maxCooldown) player.cooldown = player.maxCooldown;
                updateStaminaUI();
            }

            // Physics
            player.vy += player.gravity * dt;
            player.y += player.vy * dt;

            // Ground collision
            const groundY = height - GROUND_HEIGHT; // Use new constant
            if (player.y + player.height > groundY) {
                player.y = groundY - player.height;
                player.vy = 0;
                player.grounded = true;
                player.jumps = 0;
            } else {
                player.grounded = false;
            }

            // Obstacles - Adjusted spawn range
            const spawnDistance = 200 + Math.random() * 200; // Wider spawn range for more space
            let lastObsX = obstacles.length > 0 ? obstacles[obstacles.length-1].x : width;

            // Increased spawn chance, but with wider spacing allowed
            if (width - lastObsX > spawnDistance) {
                if (Math.random() < 0.1) spawnObstacle(); // Adjusted spawn check
            }
            if (obstacles.length === 0) spawnObstacle();

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                
                // --- Use individual speed factor for movement ---
                ob.x -= currentSpeed * ob.speedFactor * dt;
                // --------------------------------------------------

                // Collision Detection - Removed 10px buffer for accurate bounding box
                if (
                    player.x < ob.x + ob.width &&     // player left edge before obstacle right edge
                    player.x + player.width > ob.x && // player right edge after obstacle left edge
                    player.y < ob.y + ob.height &&    // player top edge before obstacle bottom edge
                    player.y + player.height > ob.y   // player bottom edge after obstacle top edge
                ) {
                    die();
                }

                if (ob.x + ob.width < 0) {
                    obstacles.splice(i, 1);
                }
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= dt;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function draw(dt) {
            ctx.clearRect(0, 0, width, height);

            // Apply screen shake offset
            let offsetX = 0;
            let offsetY = 0;
            if (screenShake > 0) {
                offsetX = Math.random() * screenShake * 20 - screenShake * 10;
                offsetY = Math.random() * screenShake * 20 - screenShake * 10;
                screenShake -= dt;
            }
            ctx.save();
            ctx.translate(offsetX, offsetY);


            // 1. Draw Sky (Gradient)
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
            skyGradient.addColorStop(0, '#55aaff'); // Light Blue
            skyGradient.addColorStop(1, '#aaffff'); // Pale Cyan
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height);
            
            // 2. Draw Mountains (Procedural Background)
            const mountainHeight = 100;
            ctx.fillStyle = '#888888'; 
            ctx.beginPath();
            ctx.moveTo(0, height - GROUND_HEIGHT); 
            
            // Draw looping mountains
            let x = 0;
            const mountainOffset = (timeSinceStart * gameSpeed * 0.05) % MOUNTAIN_WIDTH;
            for(let i = -1; i * MOUNTAIN_WIDTH < width + MOUNTAIN_WIDTH; i++) {
                const startX = i * MOUNTAIN_WIDTH - mountainOffset;
                
                // Peak 1
                ctx.lineTo(startX + MOUNTAIN_WIDTH * 0.2, height - GROUND_HEIGHT - mountainHeight * (0.5 + Math.sin(i * 1.5) * 0.1));
                // Peak 2
                ctx.lineTo(startX + MOUNTAIN_WIDTH * 0.6, height - GROUND_HEIGHT - mountainHeight * (1.0 + Math.cos(i * 1.2) * 0.1));
                // End
                ctx.lineTo(startX + MOUNTAIN_WIDTH, height - GROUND_HEIGHT);
            }
            ctx.lineTo(width, height - GROUND_HEIGHT); 
            ctx.closePath();
            ctx.fill();

            // 3. Draw Grass and Trees (Closer Background)
            const treeHeight = 50;
            ctx.fillStyle = '#00aa00'; // Dark Green Grass
            ctx.fillRect(0, height - GROUND_HEIGHT, width, GROUND_HEIGHT);

            ctx.fillStyle = '#007700'; // Darker Green Trees
            const treeOffset = (timeSinceStart * gameSpeed * 0.1) % TREE_CLUSTER_WIDTH;
            for(let i = -1; i * TREE_CLUSTER_WIDTH < width + TREE_CLUSTER_WIDTH; i++) {
                const startX = i * TREE_CLUSTER_WIDTH - treeOffset;
                
                // Tree 1
                ctx.beginPath();
                ctx.moveTo(startX + 50, height - GROUND_HEIGHT);
                ctx.lineTo(startX + 70, height - GROUND_HEIGHT - treeHeight * 0.5);
                ctx.lineTo(startX + 90, height - GROUND_HEIGHT);
                ctx.fill();
                
                // Tree 2
                ctx.beginPath();
                ctx.moveTo(startX + 150, height - GROUND_HEIGHT);
                ctx.lineTo(startX + 170, height - GROUND_HEIGHT - treeHeight);
                ctx.lineTo(startX + 190, height - GROUND_HEIGHT);
                ctx.fill();
                
                // Tree 3 (Bush)
                ctx.beginPath();
                ctx.arc(startX + 300, height - GROUND_HEIGHT - treeHeight * 0.2, 15, 0, Math.PI * 2);
                ctx.fill();
            }

            // 4. Draw Obstacles (Foreground)
            obstacles.forEach(ob => {
                let sprite;
                if (ob.type === 'block' || ob.type === 'highBarrier') {
                    sprite = sprites.block;
                    
                    // For blocks, we might need to tile the sprite vertically
                    const numBlocks = Math.round(ob.height / ob.width); 
                    for(let i = 0; i < numBlocks; i++) {
                        ctx.drawImage(
                            sprite, 
                            ob.x, 
                            ob.y + ob.height - (i + 1) * ob.width, 
                            ob.width, 
                            ob.width
                        );
                    }
                } else if (ob.type === 'toilet') {
                    sprite = sprites.toilet;
                    ctx.drawImage(sprite, ob.x, ob.y, ob.width, ob.height);
                } else if (ob.type === 'cheese') {
                    sprite = sprites.cheese;
                    ctx.drawImage(sprite, ob.x, ob.y, ob.width, ob.height);
                }
            });


            // 5. Draw Player
            ctx.drawImage(sprites.terry, player.x, player.y, player.width, player.height);
            
            // 6. Draw Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 0.5;
                ctx.fillRect(p.x, p.y, 4, 4);
                ctx.globalAlpha = 1.0;
            });
            
            ctx.restore(); // End screen shake translation
            
            // Draw foreground ground line
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, height - GROUND_HEIGHT, width, 5);
        }

        function loop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(dt);
            draw(dt);

            if (gameState !== STATE.DEAD) {
                requestAnimationFrame(loop);
            }
        }

        function startGame() {
            // Check if audio context is suspended and try to resume it on user interaction
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.log('Audio resume error:', e));
            }

            // Play BGM
            const bgm = document.getElementById('bgm');
            if(bgm) bgm.play().catch(e => console.log('BGM play error:', e));

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            // ADDED: Hide the leaderboard on the start screen when the game starts
            document.getElementById('start-leaderboard-container').classList.add('hidden');

            resetGame();
            gameState = STATE.PLAY;
            
            // Restart the loop if it was stopped
            lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function updateStaminaUI() {
            const fill = document.getElementById('jump-meter-fill');
            const percent = player.cooldown / player.maxCooldown;
            fill.style.width = `${percent * 100}%`;
            
            if (percent === 1) {
                fill.style.backgroundColor = '#00ff00';
            } else if (percent > 0.5) {
                 fill.style.backgroundColor = '#ffcc00';
            } else {
                 fill.style.backgroundColor = '#ff5555';
            }
        }

        function jump() {
            if (gameState !== STATE.PLAY) return;

            if (player.grounded) {
                // Initial jump (always works if grounded)
                player.vy = player.jumpForce;
                player.grounded = false;
                player.jumps = 1;
                playSound('jump');
                // Kick up some particles
                createParticles(player.x + player.width / 2, height - GROUND_HEIGHT, '#444', 5);
            } else if (player.jumps === 1 && player.cooldown === player.maxCooldown) {
                // Double jump (works if airborne and cooldown is ready, regardless of timing)
                player.vy = player.doubleJumpForce;
                player.jumps = 2;
                player.cooldown = 0;
                playSound('doubleJump');
                // Create double jump "puff"
                createParticles(player.x + player.width / 2, player.y + player.height / 2, '#fff', 10);
            }
        }
        
        async function die() { // Now async to await database check
            gameState = STATE.DEAD;
            playSound('death');
            // Stop Music
            const bgm = document.getElementById('bgm');
            if(bgm) { bgm.pause(); bgm.currentTime = 0; }

            screenShake = 0.5;
            const finalScore = Math.floor(score);
            document.getElementById('final-score').innerText = `SCORE: ${finalScore}`;

            // Check if score is high enough
            const isTopTen = await checkIfTopTen(finalScore);

            // Hide the submission form initially
            document.getElementById('high-score-form').classList.add('hidden');
            
            if (isTopTen) {
                // Show form if player made the top 10
                document.getElementById('high-score-form').classList.remove('hidden');
                document.getElementById('player-name').focus();
            } 
            // Removed the else block that displayed the "noble attempt" message.

            // Show the PLAY AGAIN button
            document.getElementById('restart-btn').classList.remove('hidden');

            // Show game over screen
            document.getElementById('game-over-screen').classList.remove('hidden');
            
            // Refresh and display the game-over leaderboard 
            await refreshLeaderboard(false, 'gameover'); 
            document.getElementById('gameover-leaderboard-container').classList.remove('hidden');
        }
        
        /**
         * Fetches and renders the leaderboard.
         * @param {boolean} updateTopHolder - If true, only updates the single highscore holder text.
         * @param {string} targetScreen - 'start' or 'gameover' to determine which table to update.
         */
        async function refreshLeaderboard(updateTopHolder = true, targetScreen = 'start') {
            const startTbody = document.getElementById('start-leaderboard-body');
            const gameoverTbody = document.getElementById('gameover-leaderboard-body');
            const tbody = targetScreen === 'start' ? startTbody : gameoverTbody;
            
            // Only show loading state if we are updating the full table
            if (!updateTopHolder) { 
                tbody.innerHTML = '<tr><td colspan="2">LOADING...</td></tr>';
            }
            
            const scores = await fetchLeaderboard(); 
            
            if (updateTopHolder) {
                const holderText = scores.length > 0 
                    ? `HIGHSCORE: ${scores[0].name} (${scores[0].score})`
                    : 'HIGHSCORE: BE THE FIRST!';
                document.getElementById('highscore-holder').innerText = holderText;
            }

            // Update the table body based on the target screen
            if (!updateTopHolder || targetScreen === 'start') {
                tbody.innerHTML = '';
                scores.forEach((s, index) => {
                    const tr = document.createElement('tr');
                    // Highlight the top score
                    if (index === 0) tr.style.color = '#ffff00'; 
                    tr.innerHTML = `<td>${s.name}</td><td>${s.score}</td>`;
                    tbody.appendChild(tr);
                });
                
                if (scores.length === 0) {
                     tbody.innerHTML = '<tr><td colspan="2">NO SCORES YET</td></tr>';
                }
            }
        }

        // --- EVENT LISTENERS ---
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        
        // Primary jump controls (click/tap)
        canvas.addEventListener('mousedown', jump); 
        
        canvas.addEventListener('touchstart', (e) => {
            // Prevent default touch behavior (like scrolling/pull-to-refresh)
            e.preventDefault(); 
            // Only allow single-finger taps to register a jump
            if (e.touches.length === 1) {
                jump();
            }
        });

        // Space Bar Jump for PC
        window.addEventListener('keydown', (e) => {
            if (gameState === STATE.PLAY && (e.key === ' ' || e.keyCode === 32) && !e.repeat) {
                e.preventDefault(); 
                jump(); 
            }
        });
        
        document.getElementById('submit-score-btn').addEventListener('click', async () => {
            const nameInput = document.getElementById('player-name');
            const name = nameInput.value.trim() || 'NONAME';
            
            // Save the score
            await saveScore(name, Math.floor(score));

            // Hide the form 
            document.getElementById('high-score-form').classList.add('hidden');
            
            // Refresh the displayed leaderboard to include the new score
            await refreshLeaderboard(false, 'gameover'); 
        });

        // Populate the mock leaderboard and get the initial highscore holder on load
        // UPDATED to ensure start-screen leaderboard is also populated
        refreshLeaderboard(true, 'start');
    </script>
</body>
</html>